package main

import (
	"os"
	"os/exec"
	"path/filepath"
	"testing"
)

// minimalJPEG returns a minimal valid JPEG file (1x1 red pixel)
func minimalJPEG() []byte {
	return []byte{
		0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46,
		0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,
		0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
		0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08,
		0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0A, 0x0C,
		0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
		0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D,
		0x1A, 0x1C, 0x1C, 0x20, 0x24, 0x2E, 0x27, 0x20,
		0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
		0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27,
		0x39, 0x3D, 0x38, 0x32, 0x3C, 0x2E, 0x33, 0x34,
		0x32, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0x01,
		0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4,
		0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x03, 0xFF, 0xC4, 0x00, 0x14,
		0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
		0x00, 0x00, 0x3F, 0x00, 0x37, 0xFF, 0xD9,
	}
}

// createTestJPEG creates a test JPEG file at the given path
func createTestJPEG(t *testing.T, path string) {
	t.Helper()
	if err := os.WriteFile(path, minimalJPEG(), 0644); err != nil {
		t.Fatalf("Failed to create test JPEG at %s: %v", path, err)
	}
}

// isValidJPEG checks if the data starts with JPEG magic bytes
func isValidJPEG(data []byte) bool {
	return len(data) >= 2 && data[0] == 0xFF && data[1] == 0xD8
}

func TestNewImageCompressor(t *testing.T) {
	compressor := NewImageCompressor()
	if compressor == nil {
		t.Error("Expected non-nil compressor")
	}
}

func TestJpegCompressor_CompressFile(t *testing.T) {
	if _, err := exec.LookPath("jpegoptim"); err != nil {
		t.Skip("jpegoptim not installed, skipping test")
	}

	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "test.jpg")
	createTestJPEG(t, testFile)

	originalInfo, err := os.Stat(testFile)
	if err != nil {
		t.Fatalf("Failed to stat original file: %v", err)
	}

	compressor := NewImageCompressor()
	err = compressor.CompressFile(testFile, 50)

	if err != nil {
		t.Errorf("Expected no error, got: %v", err)
	}

	if _, err := os.Stat(testFile); err != nil {
		t.Error("Compressed file should still exist")
	}

	data, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("Failed to read compressed file: %v", err)
	}
	if !isValidJPEG(data) {
		t.Error("Compressed file is not a valid JPEG")
	}

	t.Logf("Original size: %d bytes, Compressed size: %d bytes", originalInfo.Size(), len(data))
}

func TestJpegCompressor_CompressFile_NonexistentFile(t *testing.T) {
	if _, err := exec.LookPath("jpegoptim"); err != nil {
		t.Skip("jpegoptim not installed, skipping test")
	}

	compressor := NewImageCompressor()
	err := compressor.CompressFile("/nonexistent/file.jpg", 50)

	if err == nil {
		t.Error("Expected error for nonexistent file, got nil")
	}
}
